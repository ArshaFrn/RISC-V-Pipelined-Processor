00a00093   // 0: addi x1, x0, 10     ; x1 = 10 (Data A)
01400113   // 1: addi x2, x0, 20     ; x2 = 20 (Data B)
10000193   // 2: addi x3, x0, 256    ; x3 = 256 (Address Offset to cause conflict)
00102023   // 3: sw   x1, 0(x0)      ; MEM[0]=10. Cache Index 0 filled with Tag A.
0021a023   // 4: sw   x2, 0(x3)      ; MEM[256]=20. Cache Index 0 overwritten with Tag B! (Eviction)
00002203   // 5: lw   x4, 0(x0)      ; Load from MEM[0]. Cache checks Index 0, finds Tag B. MISS! Reloads 10.
0001a283   // 6: lw   x5, 0(x3)      ; Load from MEM[256]. Cache checks Index 0, finds Tag A (from prev instr). MISS! Reloads 20.
00520333   // 7: add  x6, x4, x5     ; x6 = x4 + x5 = 30. (Tests Load-Use Hazard + Forwarding)
00630463   // 8: beq  x6, x6, +8     ; Branch taken. Skips next instruction.
00000013   // 9: addi x0, x0, 0      ; NOP (Should be flushed)
0000006f   // 10: jal x0, 0          ; Infinite Loop
00000013
00000013
00000013
00000013
00000013
00000013
